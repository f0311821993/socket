#include <stdio.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/sctp.h>
#include <arpa/inet.h>

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <kodoc/kodoc.h>

#define MAX_BUFFER	1024

void error(char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
	int sockfd, new_fd, numbytes, client_length, i, ack;
	struct sockaddr_in server_addr, client_addr;
	struct stat filestat;
	struct sctp_initmsg initmsg;
	char buff[INET_ADDRSTRLEN];
	char buffer[MAX_BUFFER+1] = "Message ##\n";

    // Check command line args
    if (argc != 3) {
        printf("usage : %s [port number] [filename]\n", argv[0]);
        exit(1);
    }

	// Create the socket
	if ((sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)) == -1 )
		error("ERROR: socket");


	bzero( (void *)&server_addr, sizeof(struct sockaddr) );
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	server_addr.sin_port = htons(atoi(argv[1]));

	if (bind(sockfd, (struct sockaddr *) &server_addr, sizeof(struct sockaddr)) == -1 )
		error("ERROR: bind");

	if (listen(sockfd, 10) == -1 )
		error("ERROR: listen");

	if (lstat(argv[2], &filestat) < 0)
		error("ERROR : get file size");

	printf("Opening file: \"%s\"\n", argv[2]);
	printf("The file size is %lu bytes\n\n", filestat.st_size);

	FILE *fp;
	fp = fopen(argv[2], "r");
	client_length = sizeof(client_addr);

	/* Maximum of 3 streams will be available per socket */
	memset( &initmsg, 0, sizeof(initmsg) );
	initmsg.sinit_num_ostreams = 3;
	initmsg.sinit_max_instreams = 3;
	initmsg.sinit_max_attempts = 2;
	setsockopt( sockfd, IPPROTO_SCTP, SCTP_INITMSG, 
			&initmsg, sizeof(initmsg) );

	printf("Server Running\n");

	if ((new_fd = accept(sockfd, (struct sockaddr*) &client_addr, 
				(unsigned int *) &client_length)) == -1 )
		error("accept");
		
	/* let decoder know how many bytes file size is to end writing file */
	if (write(new_fd, &filestat.st_size, sizeof(filestat.st_size)) < 0)
		error("Error:write file_size failed");

	uint32_t max_symbols = 10;
	uint32_t max_symbol_size = 1000;

	int32_t codec = kodoc_full_vector;
	int32_t finite_field = kodoc_binary;

	kodoc_factory_t encoder_factory =
	kodoc_new_encoder_factory(codec, finite_field,
                                 max_symbols, max_symbol_size);
	kodoc_coder_t encoder = kodoc_factory_build_coder(encoder_factory);

	uint32_t bytes_used;
	uint32_t payload_size = kodoc_payload_size(encoder);
	uint32_t block_size = kodoc_block_size(encoder);
	uint8_t* payload = (uint8_t*) malloc(payload_size);
	uint8_t* data_in = (uint8_t*) malloc(block_size);

	// Encode one block at a time, check ack to know whether decoder is complete,
	// if block is decoded, read another block and encode data,
	// until all the data is encoded.	
	while (!feof(fp)) {			
		numbytes = fread(data_in, sizeof(char), block_size, fp);

		if (numbytes == 0)
			break;

		printf("\nfread %d bytes\n", numbytes);

		kodoc_set_const_symbols(encoder, data_in, block_size);
		bytes_used = kodoc_write_payload(encoder, payload);

		printf("block_size:%d\n", block_size);
		printf("payload_size:%d\n\n", payload_size);
		printf("Payload generated by encoder, rank = %d,\
			    bytes used = %d\n", kodoc_rank(encoder), bytes_used);

		socklen_t len = sizeof(struct sockaddr_in);
		sctp_sendmsg( new_fd, payload, payload_size, 
			(struct sockaddr*) &client_addr, len, 0, 0, 1 /* stream */, 0, 0 );

		while (1) {
			for(i=0; i< 3; i++) {
				if (read(new_fd, &ack, sizeof(ack)) < 0)
					error("Error:read ack failed\n");

				if (ack) {
					break;
				} else {
					bytes_used = kodoc_write_payload(encoder, payload);
					printf("Payload generated by encoder, rank = %d, bytes used = %d\n", kodoc_rank(encoder), bytes_used);

					sctp_sendmsg( new_fd, payload, payload_size, 
						(struct sockaddr *) &client_addr, len, 0, 0, i /* stream */, 0, 0 );
		
				}
			}
			if (ack) 
				break;
		} /* end of while (1) */
	} /* end of while (!feof(fp)) */

	printf("\nserver finished\n");

	close(sockfd);
	close(new_fd);
	free(data_in);
	free(payload);
	kodoc_delete_coder(encoder);
	kodoc_delete_factory(encoder_factory);
	return 0;
}
